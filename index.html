<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Host</title>
</head>
<body>
    <input type="button" id="makeCall" value="Make Call"></input>
    <p id="results"></p>
    <p>Offer Description</p>
    <p id="postResults"></p>
    <input type="button" id="setAnswer" value="Set Answer"></input>
    <p id="answerText"></p>

    <script src="js/signal.js" async></script>
    <script>
        let dataChannelDataReceived;
        let peerConnection;
        let sendChannel;
        let receiveChannel;
        const dataChannelOptions = {ordered: true};
        let dataChannelCounter = 0;
        let sendDataLoop;

        const url = 'https://script.google.com/macros/s/AKfycbwbVCo1_AozKouHDSbHeYMaxx_Azy63-UmJpyxGi3oGmFwCatd-6SEwkZtDgQ-KV0J4qw/exec'
        
        document.getElementById("makeCall").addEventListener("click", makeCall)
        document.getElementById("setAnswer").addEventListener("click", setAnswer)

        async function makeCall() {
            console.log("creating peer connection")
            const configuration = {'iceServers': [
                {'urls': 'stun:stun.l.google.com:19302'},
                {'urls': 'stun:stun.l.google.com:5349'}
            ]};
            peerConnection = new RTCPeerConnection(configuration);
            console.log('Created local peer connection object peerConnection');
            
            peerConnection.onicecandidate = e => {
                console.log("on ice callback",e)
                onIceCandidate(peerConnection, e)};
            
            sendChannel = peerConnection.createDataChannel('sendDataChannel', dataChannelOptions);
            sendChannel.onopen = onSendChannelStateChange;
            sendChannel.onclose = onSendChannelStateChange;
            sendChannel.onerror = onSendChannelStateChange;
            
        }
        
        async function setAnswer(){
            let answer = await getData(`${url}?step=4`);
            answer = JSON.parse(answer)
            console.log(answer)
            document.getElementById("answerText").innerText = JSON.stringify(answer);
            if (answer) {
                const remoteDesc = new RTCSessionDescription(answer);
                await peerConnection.setRemoteDescription(remoteDesc);
            }
        }
        
        //getData()
        
        function sendData() {
            if (sendChannel.readyState === 'open') {
                sendChannel.send(dataChannelCounter);
                console.log(`DataChannel send counter: ${dataChannelCounter}`);
                dataChannelCounter++;
            }
        }
        
        async function onIceCandidate(pc, event) {
            try {
                // eslint-disable-next-line no-unused-vars
                console.log(`Ice gather status. ${pc.iceGatheringState}`);
                console.log(`event stringify ${JSON.stringify(event)}`);
                console.log(`event ${event.candidate}`);
                const ignore = await pc.addIceCandidate(event.candidate);
                onAddIceCandidateSuccess(pc);
            } catch (e) {
                onAddIceCandidateError(pc, e);
            }
            
            console.log(`${pc} ICE candidate:\n${event.candidate ? event.candidate.candidate : '(null)'}`);
        }
        
        async function onAddIceCandidateSuccess() {
            
            console.log(`AddIceCandidate success. ${iceGatheringState}`);
            
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            console.log(offer)
            
            postData(offer,`${url}?step=1`).then( (data) => document.getElementById('postResults').innerText = data);
            }

            function onAddIceCandidateError(error) {
                console.log(`Failed to add Ice Candidate: ${error.toString()}`);
            }

            function receiveChannelCallback(event) {
                console.log('Receive Channel Callback');
                receiveChannel = event.channel;
                receiveChannel.onmessage = onReceiveMessageCallback;
                receiveChannel.onopen = onReceiveChannelStateChange;
                receiveChannel.onclose = onReceiveChannelStateChange;
            }

            function onReceiveMessageCallback(event) {
                dataChannelDataReceived = event.data;
                console.log(`DataChannel receive counter: ${dataChannelDataReceived}`);
            }

            function onSendChannelStateChange() {
                const readyState = sendChannel.readyState;
                console.log(`Send channel state is: ${readyState}`);
                if (readyState === 'open') {
                    sendDataLoop = setInterval(sendData, 1000);
                } else {
                    clearInterval(sendDataLoop);
                }
            }

            function onReceiveChannelStateChange() {
                const readyState = receiveChannel.readyState;
                console.log(`Receive channel state is: ${readyState}`);
            }
    </script>
</body>
</html>